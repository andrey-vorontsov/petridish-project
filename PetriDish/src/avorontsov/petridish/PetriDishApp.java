package avorontsov.petridish;

import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ObservableList;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.scene.control.Button;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.stage.WindowEvent;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;

/**
 * The App class launches the application, starts associated threads and opens
 * windows. It also contains all user input handling code that is run on the
 * JavaFX thread.
 * 
 * @author Andrey Vorontsov
 */
public class PetriDishApp extends Application {

	// TODO fields need to be configurable
	public static final int PETRI_DISH_WIDTH = 750;
	public static final int PETRI_DISH_HEIGHT = 750;
	public static final long SIMULATION_TICK_DELAY_MS = 30;// this is the default minimum time between update ticks of the simulation. At least this much time will pass between each graphics update request generated by the simulation thread
	// Some notes. Around 20 ms is the minimum tick delay to avoid inconsistent tick
	// rate, on my machine, with under 1000 cells. Delay grows much faster as cell
	// count increases. As cell number increases, simulation complexity increases
	// faster than graphics complexity. Since the graphics thread is also handling
	// all the JavaFX layers and events, it slows down whenever an event occurs
	// (e.g. user click); if delay is uncapped, JavaFX behavior is also quite strange (bursts of motion)
	
	private Group guiRoot; // the root node of the GUI window scene graph
	private Group petriRoot; // the root node of the simulation window scene graph
	private PetriDish petri; // the thread responsible for running the simulation in parallel to the GUI
								// thread
	
	// GUI state information
	
	private boolean simulationPaused; // true only when the simulation is paused
	private long simulationDelay; // ranges from 0 (framerate uncapped) to 100 (10 fps)
									// changes are applied at the end of each simulation cycle

	/**
	 * Launches the Petri Dish application (JavaFX Application thread startup).
	 * 
	 * @param args unused
	 */
	public static void main(String[] args) {
		launch(args);
	}

	/**
	 * Initializes the GUI and simulation windows, then starts the simulation
	 * thread. After this method runs at launch, there are two windows open and two
	 * threads running (one graphics thread updating both windows, one simulation
	 * thread running the petri dish in the background).
	 * 
	 * @see javafx.application.Application#start(javafx.stage.Stage)
	 * @param appWindow supplied by JavaFX
	 * @throws Exception by the default JavaFX method - it seems JavaFX is able to
	 *                   handle certain exceptions and keep breathing
	 */
	@Override
	public void start(Stage appWindow) throws Exception {
		
		// initialize GUI state information
		
		simulationPaused = false;
		simulationDelay = SIMULATION_TICK_DELAY_MS;

		// initializing GUI window "control panel" as the master window

		// setup the scene graph
		guiRoot = new Group();
		ObservableList<Node> allGuiNodes = guiRoot.getChildren();
		
		 // I suppose I should learn to use javafx layouts; currently, every node is just being dumped in haphazardly TODO

		// welcome message/status info placeholder
		Text currMsg = new Text("Welcome to Petri Dish.");
		currMsg.setX(30);
		currMsg.setY(30);
		allGuiNodes.add(currMsg);
		
		// pause/play button implementation TODO allow to interrupt update
		Button pause = new Button("Pause");
		pause.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent event) {
				if (pause.getText().equals("Pause")) {
					pause.setText("Play");
					simulationPaused = true;
				} else {
					pause.setText("Pause");
					simulationPaused = false;
				}
				
			}
			
		});
		pause.setLayoutX(30);
		pause.setLayoutY(60);
		allGuiNodes.add(pause);
		// end of pause/play button
		
		// simulation speed text box and slider implementation
		// text box (accepts and validates input when enter key is pressed)
		TextField simSpeedMsg = new TextField();	
		simSpeedMsg.setText(simulationDelay + "");
		simSpeedMsg.setMaxWidth(50);
		simSpeedMsg.setLayoutX(180);
		simSpeedMsg.setLayoutY(150);
		
		// simulation speed slider (any change is applied immediately)
		Slider simSpeed = new Slider(0, 100, 30);
		simSpeed.setBlockIncrement(1); // increments of 1 ms
		simSpeed.setMajorTickUnit(10);
		simSpeed.setMinorTickCount(1);
		simSpeed.setShowTickMarks(true);
		simSpeed.setLayoutX(30);
		simSpeed.setLayoutY(150);

		// handling enter key input from text field
		simSpeedMsg.setOnKeyReleased(new EventHandler<KeyEvent>() {

			@Override
			public void handle(KeyEvent keyReleasedEvent) {
				
				// only when the enter key is pressed
				if (keyReleasedEvent.getCode().equals(KeyCode.ENTER)) {
					
					// validate input to be a valid long
					try {
						simulationDelay = Long.parseLong(simSpeedMsg.getText());
						if (simulationDelay < simSpeed.getMin()) {
							simSpeedMsg.setText((long) simSpeed.getMin() + ""); // TODO check if safe
						} else if(simulationDelay > simSpeed.getMax()) {
							simSpeedMsg.setText((long) simSpeed.getMax() + ""); // TODO check if safe
						}
					} catch (NumberFormatException e) {
						simSpeedMsg.setText(simulationDelay + ""); // TODO give an indication of needing a valid number
						// simulationSpeed is not updated
					}
					// update the slider to correspond
					simSpeed.setValue(simulationDelay);
				}
				
			}
			
		});
		
		// handling slider input
		simSpeed.valueProperty().addListener(new ChangeListener<Number>() {

			@Override
			public void changed(ObservableValue<? extends Number> observableValue, Number oldValue, Number newValue) {
				// slider ensures that the input is always valid
				simulationDelay = Math.round((double)newValue); // TODO check if ok to do this
				simSpeedMsg.setText(simulationDelay + "");
				
			}
			
		});

		allGuiNodes.add(simSpeedMsg);
		allGuiNodes.add(simSpeed);
		// finished simulation speed controls
		
		// set the GUI window's dimensions
		Scene scene = new Scene(guiRoot, 350, 600);

		// set the GUI window's stats incl. title, location
		appWindow.setTitle("Control Panel");
		appWindow.setScene(scene);
		appWindow.setResizable(false);
		appWindow.setX(25);
		appWindow.setY(25);
		// finished setting up the GUI window

		// initialize simulation window "petri dish"

		Stage petriWindow = new Stage();

		petriRoot = new Group();

		// no nodes; initially simulation window is blank, so no need to modify
		// petriRoot's children

		// set the petri dish window dimensions from configuration
		Scene petriScene = new Scene(petriRoot, PETRI_DISH_WIDTH, PETRI_DISH_HEIGHT);

		// set the petri dish window's stats, incl. title, location
		petriWindow.setTitle("Petri Dish");
		petriWindow.setScene(petriScene);
		petriWindow.setResizable(false);
		petriWindow.setX(425);
		petriWindow.setY(100);

		// set up closing behavior of the two windows

		appWindow.setOnCloseRequest(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent event) { // the GUI window closes the whole application before closing itself
				stop();
				petriWindow.close();
			}
		});
		petriWindow.setOnCloseRequest(new EventHandler<WindowEvent>() {
			@Override
			public void handle(WindowEvent event) { // the simulation window does not close if asked
				event.consume();
			}
		});

		// both windows are ready, show them

		appWindow.show();
		petriWindow.show();

		// start the simulation thread and give it a hook to this thread

		petri = new PetriDish(this);

	}

	/**
	 * Gets the root node of the scene graph of the simulation window, allowing the
	 * auxiliary thread to get a reference to send graphics to.
	 * 
	 * @return the root node of the scene graph of the simulation window
	 */
	public Group getPetriRoot() {
		return petriRoot;
	}

	/**
	 * When the app closes it will terminate the simulation thread as well. The
	 * simulation will terminate once it finishes the simulation tick it was working
	 * on at the time.
	 * 
	 * @see javafx.application.Application#stop()
	 */
	@Override
	public void stop() {
		if (petri != null)
			petri.stop();
	}

	/**
	 * @return true only while the simulation has been paused by GUI input
	 */
	public boolean isSimulationPaused() {
		return simulationPaused;
	}

	/**
	 * @return the simulationDelay (ms)
	 */
	public long getSimulationDelay() {
		return simulationDelay;
	}

}
